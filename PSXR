local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/memejames/elerium-v2-ui-library//main/Library", true))()
local window = library:AddWindow("TINY Games", {
    main_color = Color3.fromRGB(41, 74, 122),
    min_size = Vector2.new(700, 500),
    can_resize = false,
})

-- Services
local Players = game:GetService("Players")
local TS = game:GetService("TweenService")

-- Global variables for orb collection
_G.collectOrbs = false
local orbConnection = nil

-- Global variables for autofarm
_G.autoFarmEnabled = false
local autoFarmConnection = nil

-- Global variables for teleport
_G.teleportAround = false
local teleportConnection = nil
local voidProtectionPart = nil

-- player
local plr = Players.LocalPlayer
local char = plr.Character
local humanoid = char.Humanoid

-- Void Protection Functions
local function createVoidProtection()
    if voidProtectionPart then
        voidProtectionPart:Destroy()
    end
    
    voidProtectionPart = Instance.new("Part")
    voidProtectionPart.Name = "VoidProtection"
    voidProtectionPart.Size = Vector3.new(10, 1, 10)
    voidProtectionPart.Material = Enum.Material.ForceField
    voidProtectionPart.Transparency = 0.8
    voidProtectionPart.Anchored = true
    voidProtectionPart.CanCollide = true
    voidProtectionPart.BrickColor = BrickColor.new("Bright blue")
    voidProtectionPart.Parent = workspace
    
    return voidProtectionPart
end

local function updateVoidProtection()
    local player = Players.LocalPlayer
    if not player then return end
    local character = player.Character
    if not character then return end
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    if not voidProtectionPart then
        createVoidProtection()
    end
    
    -- Position the platform 10 studs below the player
    local playerPos = HumanoidRootPart.Position
    voidProtectionPart.CFrame = CFrame.new(playerPos.X, playerPos.Y - 10, playerPos.Z)
end

local function removeVoidProtection()
    if voidProtectionPart then
        voidProtectionPart:Destroy()
        voidProtectionPart = nil
    end
end

-- Teleport Functions
local function CheckTeleportDistance(Mesh)
    local player = Players.LocalPlayer
    if not player then return false end
    local character = player.Character
    if not character then return false end
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return false end
    
    local distance = (HumanoidRootPart.Position - Mesh.Position).Magnitude
    return distance <= 100
end

local function TeleportAround()
    if teleportConnection then
        task.cancel(teleportConnection)
        teleportConnection = nil
    end
    
    teleportConnection = task.spawn(function()
        while _G.teleportAround do
            task.wait(5)
            
            local things = workspace:FindFirstChild("__THINGS")
            if not things then continue end
            local coins = things:FindFirstChild("Coins")
            if not coins then continue end
            
            local player = Players.LocalPlayer
            if not player then continue end
            local character = player.Character
            if not character then continue end
            local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if not HumanoidRootPart then continue end
            
            for i, folder in pairs(coins:GetChildren()) do
                if not _G.teleportAround then break end
                
                local coinMesh = folder:FindFirstChild("Coin")
                if coinMesh then
                    local inRange = CheckTeleportDistance(coinMesh)
                    if inRange then
                        -- Create teleport position slightly above the coin to avoid getting stuck
                        local targetCFrame = coinMesh.CFrame + Vector3.new(0, 5, 0)
                        
                        local TI = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                        local Tween = TS:Create(HumanoidRootPart, TI, {CFrame = targetCFrame})
                        Tween:Play()
                        
                        -- Update void protection during teleport
                        if _G.teleportAround then
                            updateVoidProtection()
                        end
                        
                        Tween.Finished:Wait()
                        
                        -- Update void protection after teleport
                        if _G.teleportAround then
                            updateVoidProtection()
                        end
                    end
                end
            end
        end
    end)
end

local function startTeleportAround()
    _G.teleportAround = true
    createVoidProtection()
    TeleportAround()
    
    -- Monitor player position for void protection updates
    task.spawn(function()
        while _G.teleportAround do
            task.wait(0.5)
            updateVoidProtection()
        end
    end)
end

local function stopTeleportAround()
    _G.teleportAround = false
    if teleportConnection then
        task.cancel(teleportConnection)
        teleportConnection = nil
    end
    removeVoidProtection()
end

-- Orb Collection Functions
local function ClaimAllOrbs()
    if not _G.collectOrbs then return end
    
    local player = Players.LocalPlayer
    if not player then return end
    local character = player.Character or player.CharacterAdded:Wait()
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    local orbsFolder = workspace:FindFirstChild("__THINGS")
    if not orbsFolder then return end
    orbsFolder = orbsFolder:FindFirstChild("Orbs")
    if not orbsFolder then return end
    
    local allorbs = orbsFolder:GetChildren()
    for _, orb in pairs(allorbs) do
        if orb:IsA("BasePart") or orb:IsA("Model") then
            local ti = TweenInfo.new(
                0.1,
                Enum.EasingStyle.Quad,
                Enum.EasingDirection.In
            )
            local tween = TS:Create(orb, ti, {CFrame = HumanoidRootPart.CFrame})
            tween:Play()
        end
    end
end

local function startOrbCollection()
    if orbConnection then
        orbConnection:Disconnect()
        orbConnection = nil
    end
    
    -- Initial collection
    ClaimAllOrbs()
    
    -- Monitor for new orbs
    local orbsFolder = workspace:FindFirstChild("__THINGS")
    if orbsFolder then
        orbsFolder = orbsFolder:FindFirstChild("Orbs")
        if orbsFolder then
            orbConnection = orbsFolder.ChildAdded:Connect(function()
                if _G.collectOrbs then
                    wait(0.1) -- Small delay to ensure orb is fully loaded
                    ClaimAllOrbs()
                end
            end)
        end
    end
end

local function stopOrbCollection()
    if orbConnection then
        orbConnection:Disconnect()
        orbConnection = nil
    end
end

-- Autofarm Functions
local function GetListLength(list)
    local len = 1
    for i, v in pairs(list) do
        len += 1
    end
    return len
end

local function GetPlayerPets()
    local Pets = workspace:FindFirstChild("__THINGS")
    if not Pets then return {} end
    Pets = Pets:FindFirstChild("Pets")
    if not Pets then return {} end
    
    local plrpets = {}
    for i, pet in pairs(Pets:GetChildren()) do
        local Owner = pet:GetAttribute("Owner")
        if Owner == Players.LocalPlayer.Name then
            plrpets[GetListLength(plrpets)] = pet.Name
        end
    end
    return plrpets
end

local function AttackCoin(coinid)
    local playerpets = GetPlayerPets()
    if #playerpets == 0 then return end
    
    local petToAttack = playerpets[math.random(1, GetListLength(playerpets))]
    
    pcall(function()
        workspace.__THINGS.__REMOTES["join coin"]:InvokeServer({
            [1] = coinid,
            [2] = {
                [1] = petToAttack,
            },
        })
        workspace.__THINGS.__REMOTES["change pet target"]:FireServer({
            [1] = petToAttack,
            [2] = "Coin",
            [3] = coinid,
        })
        workspace.__THINGS.__REMOTES["farm coin"]:FireServer({
            [1] = coinid,
            [2] = petToAttack,
        })
    end)
end

local function CheckDistance(mesh)
    local player = Players.LocalPlayer
    if not player then return false end
    local character = player.Character
    if not character then return false end
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return false end
    
    local distance = (HumanoidRootPart.Position - mesh.Position).Magnitude
    return distance <= 250
end

local function startAutoFarm()
    if autoFarmConnection then
        autoFarmConnection:Disconnect()
        autoFarmConnection = nil
    end
    
    autoFarmConnection = task.spawn(function()
        while _G.autoFarmEnabled do
            task.wait(1)
            
            local things = workspace:FindFirstChild("__THINGS")
            if not things then continue end
            local coins = things:FindFirstChild("Coins")
            if not coins then continue end
            
            for i, folder in pairs(coins:GetChildren()) do
                if not _G.autoFarmEnabled then break end
                
                local coinMesh = folder:FindFirstChild("Coin")
                if coinMesh then
                    local inRange = CheckDistance(coinMesh)
                    if inRange then
                        AttackCoin(folder.Name)
                    end
                end
            end
        end
    end)
end

local function stopAutoFarm()
    _G.autoFarmEnabled = false
    if autoFarmConnection then
        task.cancel(autoFarmConnection)
        autoFarmConnection = nil
    end
end

-- AutoFarm Tab
local autofarm = window:AddTab("AutoFarm") -- Name of tab
autofarm:Show() -- shows the tab
autofarm:AddLabel("Main")

-- Modified Autofarm Switch with integrated functionality
local switch = autofarm:AddSwitch("Autofarm (Breakable aura)", function(bool)
    _G.autoFarmEnabled = bool
    if bool then
        startAutoFarm()
    else
        stopAutoFarm()
    end
end)
switch:Set(false)

-- Collect Orbs Toggle (Modified)
local orbSwitch = autofarm:AddSwitch("Collect orbs", function(bool)
    _G.collectOrbs = bool
    if bool then
        startOrbCollection()
    else
        stopOrbCollection()
    end
end)
orbSwitch:Set(false)

local switch = autofarm:AddSwitch("Collect Lootbags", function(bool)
     -- toggle_god_mode(bool)
end)
switch:Set(false)

-- Integrated Teleport Around Switch
local teleportSwitch = autofarm:AddSwitch("Teleport Around (Private Platform)", function(bool)
    if bool then
        startTeleportAround()
    else
        stopTeleportAround()
    end
end)
teleportSwitch:Set(false)

local dropdown = autofarm:AddDropdown("Select Teleport Area", function(text)
    if text == "Spawn" then  -- Code
        print("o")
    elseif text == "Forest" then
    print("k")
    elseif text == "Beach" then
    print("Weeeee")
    end
end)
local mars = dropdown:Add("Spawn")  -- Options
local earth = dropdown:Add("Forest")
local not_a_planet = dropdown:Add("Beach")

autofarm:AddLabel("Chests")

local switch = autofarm:AddSwitch("Autofarm Big Chests", function(bool)
     -- toggle_god_mode(bool)
end)
switch:Set(false)

local switch = autofarm:AddSwitch("Teleport under chest (Private Platform)", function(bool)
     -- toggle_god_mode(bool)
end)
switch:Set(false)

local dropdown = autofarm:AddDropdown("Select Chest", function(text)
    if text == "Spawn" then  -- Code
        print("o")
    elseif text == "Forest" then
    print("k")
    elseif text == "Beach" then
    print("Weeeee")
    end
end)
local volcano= dropdown:Add("Volcano")  -- Options
local fantasy = dropdown:Add("Fantasy")
local haunted = dropdown:Add("Haunted")
local hell = dropdown:Add("Hell")
local heaven = dropdown:Add("Heaven")
local heavenbig = dropdown:Add("Heaven Big")

-- Eggs Tab
local features = window:AddTab("Eggs") -- Name of tab
_G.autoBuyEgg = false
_G.eggName = "Spotted Egg"
_G.eggBuySpeed = 1

local function startAutoBuyEgg()
    task.spawn(function()
        local things = workspace:WaitForChild("__THINGS", 5)
        if not things then return end
        local remotes = things:WaitForChild("__REMOTES", 5)
        if not remotes then return end
        local buyEgg = remotes:WaitForChild("buy egg", 5)
        if not buyEgg then return end
       
        while _G.autoBuyEgg do
            local args = {
                {
                    _G.eggName,
                    false
                }
            }
            pcall(function()
                buyEgg:InvokeServer(unpack(args))
            end)
            task.wait(0.6 - (_G.eggBuySpeed * 0.1))
        end
    end)
end

local switch = features:AddSwitch("auto fast hatch egg", function(bool)
    _G.autoBuyEgg = bool
    if bool then
        startAutoBuyEgg()
    end
end)

local speedSlider = features:AddSlider("buy egg speed", function(value)
    _G.eggBuySpeed = value
end, {
    ["min"] = 1,
    ["max"] = 5,
})

local features = window:AddTab("Misc") -- Name of tab
_G.Walkspeed = 16
_G.JumpHeight = 50
_G.Modifying = false

local walkSpeedSlider = features:AddSlider("Set Walkspeed", function(value)
    _G.Walkspeed = value
end, {
    ["min"] = 1,
    ["max"] = 200,
})
local jumpHeightSlider = features:AddSlider("Set Jumpheight", function(value)
    _G.JumpHeight = value
end, {
    ["min"] = 1,
    ["max"] = 500,
})
local modifyingSwitch = features:AddSwitch("Modifying?", function(bool)
    _G.Modifying = bool
end)

task.spawn(function()
    while task.wait() do
        if _G.Modifying then
            humanoid.WalkSpeed = _G.Walkspeed
            humanoid.JumpHeight = _G.JumpHeight
        else
            humanoid.WalkSpeed = 16
            humanoid.JumpHeight = 50
        end
    end
end)

modifyingSwitch:Set(false)
jumpHeightSlider:Set(50)
walkSpeedSlider:Set(16)
speedSlider:Set(1)
switch:Set(false)

-- Cleanup when player leaves
Players.PlayerRemoving:Connect(function(player)
    if player == Players.LocalPlayer then
        removeVoidProtection()
    end
end)
