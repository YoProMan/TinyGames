local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/memejames/elerium-v2-ui-library//main/Library", true))()
local window = library:AddWindow("TINY Games", {
    main_color = Color3.fromRGB(41, 74, 122),
    min_size = Vector2.new(700, 500),
    can_resize = false,
})

-- Services
local Players = game:GetService("Players")
local TS = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- Global variables for orb collection
_G.collectOrbs = false
local orbConnection = nil

-- Global variables for autofarm
_G.autoFarmEnabled = false
local autoFarmConnection = nil

-- Global variables for teleport
_G.teleportAround = false
local teleportConnection = nil
local voidProtectionPart = nil

-- Global variables for breakable aura visualization
_G.showBreakableAura = false
_G.customSliderValue = 250
local breakableAuraSphere = nil
local auraUpdateConnection = nil

-- player
local plr = Players.LocalPlayer
local char = plr.Character
local humanoid = char.Humanoid

-- Breakable Aura Visualization Functions
local function createBreakableAuraSphere()
    if breakableAuraSphere then
        breakableAuraSphere:Destroy()
    end
    
    breakableAuraSphere = Instance.new("Part")
    breakableAuraSphere.Name = "BreakableAuraSphere"
    breakableAuraSphere.Shape = Enum.PartType.Ball
    breakableAuraSphere.Material = Enum.Material.ForceField
    breakableAuraSphere.Transparency = 0.7
    breakableAuraSphere.Anchored = true
    breakableAuraSphere.CanCollide = false
    breakableAuraSphere.BrickColor = BrickColor.new("Bright green")
    breakableAuraSphere.Parent = workspace
    
    -- Set initial size based on slider value
    local radius = _G.customSliderValue or 250
    breakableAuraSphere.Size = Vector3.new(radius * 2, radius * 2, radius * 2)
    
    return breakableAuraSphere
end

local function updateBreakableAuraSphere()
    local player = Players.LocalPlayer
    if not player then return end
    local character = player.Character
    if not character then return end
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    if not breakableAuraSphere then
        createBreakableAuraSphere()
    end
    
    -- Update position to follow player
    breakableAuraSphere.Position = HumanoidRootPart.Position
    
    -- Update size based on slider value
    local radius = _G.customSliderValue or 250
    breakableAuraSphere.Size = Vector3.new(radius * 2, radius * 2, radius * 2)
end

local function removeBreakableAuraSphere()
    if breakableAuraSphere then
        breakableAuraSphere:Destroy()
        breakableAuraSphere = nil
    end
    if auraUpdateConnection then
        auraUpdateConnection:Disconnect()
        auraUpdateConnection = nil
    end
end

local function startBreakableAuraVisualization()
    _G.showBreakableAura = true
    createBreakableAuraSphere()
    
    -- Update sphere position and size continuously
    auraUpdateConnection = RunService.Heartbeat:Connect(function()
        if _G.showBreakableAura then
            updateBreakableAuraSphere()
        end
    end)
end

local function stopBreakableAuraVisualization()
    _G.showBreakableAura = false
    removeBreakableAuraSphere()
end

-- Void Protection Functions
local function createVoidProtection()
    if voidProtectionPart then
        voidProtectionPart:Destroy()
    end
    
    voidProtectionPart = Instance.new("Part")
    voidProtectionPart.Name = "VoidProtection"
    voidProtectionPart.Size = Vector3.new(10, 1, 10)
    voidProtectionPart.Material = Enum.Material.ForceField
    voidProtectionPart.Transparency = 0.8
    voidProtectionPart.Anchored = true
    voidProtectionPart.CanCollide = true
    voidProtectionPart.BrickColor = BrickColor.new("Bright blue")
    voidProtectionPart.Parent = workspace
    
    return voidProtectionPart
end

local function updateVoidProtection()
    local player = Players.LocalPlayer
    if not player then return end
    local character = player.Character
    if not character then return end
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    if not voidProtectionPart then
        createVoidProtection()
    end
    
    -- Position the platform 10 studs below the player
    local playerPos = HumanoidRootPart.Position
    voidProtectionPart.CFrame = CFrame.new(playerPos.X, playerPos.Y - 10, playerPos.Z)
end

local function removeVoidProtection()
    if voidProtectionPart then
        voidProtectionPart:Destroy()
        voidProtectionPart = nil
    end
end

-- Teleport Functions
local function CheckTeleportDistance(Mesh)
    local player = Players.LocalPlayer
    if not player then return false end
    local character = player.Character
    if not character then return false end
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return false end
    
    local distance = (HumanoidRootPart.Position - Mesh.Position).Magnitude
    return distance <= 100
end

local function TeleportAround()
    if teleportConnection then
        task.cancel(teleportConnection)
        teleportConnection = nil
    end
    
    teleportConnection = task.spawn(function()
        while _G.teleportAround do
            task.wait(5)
            
            local things = workspace:FindFirstChild("__THINGS")
            if not things then continue end
            local coins = things:FindFirstChild("Coins")
            if not coins then continue end
            
            local player = Players.LocalPlayer
            if not player then continue end
            local character = player.Character
            if not character then continue end
            local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if not HumanoidRootPart then continue end
            
            for i, folder in pairs(coins:GetChildren()) do
                if not _G.teleportAround then break end
                
                local coinMesh = folder:FindFirstChild("Coin")
                if coinMesh then
                    local inRange = CheckTeleportDistance(coinMesh)
                    if inRange then
                        -- Create teleport position slightly above the coin to avoid getting stuck
                        local targetCFrame = coinMesh.CFrame + Vector3.new(0, 5, 0)
                        
                        local TI = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                        local Tween = TS:Create(HumanoidRootPart, TI, {CFrame = targetCFrame})
                        Tween:Play()
                        
                        -- Update void protection during teleport
                        if _G.teleportAround then
                            updateVoidProtection()
                        end
                        
                        Tween.Finished:Wait()
                        
                        -- Update void protection after teleport
                        if _G.teleportAround then
                            updateVoidProtection()
                        end
                    end
                end
            end
        end
    end)
end

local function startTeleportAround()
    _G.teleportAround = true
    createVoidProtection()
    TeleportAround()
    
    -- Monitor player position for void protection updates
    task.spawn(function()
        while _G.teleportAround do
            task.wait(0.5)
            updateVoidProtection()
        end
    end)
end

local function stopTeleportAround()
    _G.teleportAround = false
    if teleportConnection then
        task.cancel(teleportConnection)
        teleportConnection = nil
    end
    removeVoidProtection()
end

-- Orb Collection Functions
local function ClaimAllOrbs()
    if not _G.collectOrbs then return end
    
    local player = Players.LocalPlayer
    if not player then return end
    local character = player.Character or player.CharacterAdded:Wait()
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    local orbsFolder = workspace:FindFirstChild("__THINGS")
    if not orbsFolder then return end
    orbsFolder = orbsFolder:FindFirstChild("Orbs")
    if not orbsFolder then return end
    
    local allorbs = orbsFolder:GetChildren()
    for _, orb in pairs(allorbs) do
        if orb:IsA("BasePart") or orb:IsA("Model") then
            local ti = TweenInfo.new(
                0.1,
                Enum.EasingStyle.Quad,
                Enum.EasingDirection.In
            )
            local tween = TS:Create(orb, ti, {CFrame = HumanoidRootPart.CFrame})
            tween:Play()
        end
    end
end

local function startOrbCollection()
    if orbConnection then
        orbConnection:Disconnect()
        orbConnection = nil
    end
    
    -- Initial collection
    ClaimAllOrbs()
    
    -- Monitor for new orbs
    local orbsFolder = workspace:FindFirstChild("__THINGS")
    if orbsFolder then
        orbsFolder = orbsFolder:FindFirstChild("Orbs")
        if orbsFolder then
            orbConnection = orbsFolder.ChildAdded:Connect(function()
                if _G.collectOrbs then
                    wait(0.1) -- Small delay to ensure orb is fully loaded
                    ClaimAllOrbs()
                end
            end)
        end
    end
end

local function stopOrbCollection()
    if orbConnection then
        orbConnection:Disconnect()
        orbConnection = nil
    end
end

-- Autofarm Functions
local function GetListLength(list)
    local len = 1
    for i, v in pairs(list) do
        len += 1
    end
    return len
end

local function GetPlayerPets()
    local Pets = workspace:FindFirstChild("__THINGS")
    if not Pets then return {} end
    Pets = Pets:FindFirstChild("Pets")
    if not Pets then return {} end
    
    local plrpets = {}
    for i, pet in pairs(Pets:GetChildren()) do
        local Owner = pet:GetAttribute("Owner")
        if Owner == Players.LocalPlayer.Name then
            plrpets[GetListLength(plrpets)] = pet.Name
        end
    end
    return plrpets
end

local function AttackCoin(coinid)
    local playerpets = GetPlayerPets()
    if #playerpets == 0 then return end
    
    local petToAttack = playerpets[math.random(1, GetListLength(playerpets))]
    
    pcall(function()
        workspace.__THINGS.__REMOTES["join coin"]:InvokeServer({
            [1] = coinid,
            [2] = {
                [1] = petToAttack,
            },
        })
        workspace.__THINGS.__REMOTES["change pet target"]:FireServer({
            [1] = petToAttack,
            [2] = "Coin",
            [3] = coinid,
        })
        workspace.__THINGS.__REMOTES["farm coin"]:FireServer({
            [1] = coinid,
            [2] = petToAttack,
        })
    end)
end

-- Updated CheckDistance function to use the custom slider value
local function CheckDistance(mesh)
    local player = Players.LocalPlayer
    if not player then return false end
    local character = player.Character
    if not character then return false end
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return false end
    
    local distance = (HumanoidRootPart.Position - mesh.Position).Magnitude
    return distance <= (_G.customSliderValue or 250)
end

local function startAutoFarm()
    if autoFarmConnection then
        autoFarmConnection:Disconnect()
        autoFarmConnection = nil
    end
    
    autoFarmConnection = task.spawn(function()
        while _G.autoFarmEnabled do
            task.wait(1)
            
            local things = workspace:FindFirstChild("__THINGS")
            if not things then continue end
            local coins = things:FindFirstChild("Coins")
            if not coins then continue end
            
            for i, folder in pairs(coins:GetChildren()) do
                if not _G.autoFarmEnabled then break end
                
                local coinMesh = folder:FindFirstChild("Coin")
                if coinMesh then
                    local inRange = CheckDistance(coinMesh)
                    if inRange then
                        AttackCoin(folder.Name)
                    end
                end
            end
        end
    end)
end

local function stopAutoFarm()
    _G.autoFarmEnabled = false
    if autoFarmConnection then
        task.cancel(autoFarmConnection)
        autoFarmConnection = nil
    end
end

-- AutoFarm Tab
local autofarm = window:AddTab("AutoFarm") -- Name of tab
autofarm:Show() -- shows the tab
autofarm:AddLabel("Main")

-- Modified Autofarm Switch with integrated functionality
local autofarmSwitch = autofarm:AddSwitch("Autofarm (Breakable aura)", function(bool)
    _G.autoFarmEnabled = bool
    if bool then
        startAutoFarm()
    else
        stopAutoFarm()
    end
end)
autofarmSwitch:Set(false)

-- Collect Orbs Toggle (Modified)
local orbSwitch = autofarm:AddSwitch("Collect orbs", function(bool)
    _G.collectOrbs = bool
    if bool then
        startOrbCollection()
    else
        stopOrbCollection()
    end
end)
orbSwitch:Set(false)

local lootbagSwitch = autofarm:AddSwitch("Collect Lootbags", function(bool)
     -- toggle_god_mode(bool)
end)
lootbagSwitch:Set(false)

-- Integrated Teleport Around Switch
local teleportSwitch = autofarm:AddSwitch("Teleport To Middle", function(bool)
    if bool then
        startTeleportAround()
    else
        stopTeleportAround()
    end
end)
teleportSwitch:Set(false)

local dropdown = autofarm:AddDropdown("Select Teleport Area (Tech)", function(text)
    if text == "Tech City" then  -- Code
    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Tech City"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)

    elseif text == "Dark Tech" then
    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Dark Tech"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)

    elseif text == "Steampunk" then
    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Steampunk"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)

    elseif text == "Alien lab" then
    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Alien Lab"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)

    elseif text == "Alien Forest" then
    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Alien Forest"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)

    elseif text == "Glitch" then
    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Glitch"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)

    elseif text == "HackerPortal" then
    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Hacker Portal"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)

    end
end)
local techcity = dropdown:Add("Tech City")  -- Options
local darktech = dropdown:Add("Dark Tech")
local steampunk = dropdown:Add("Steampunk")
local alienlab = dropdown:Add("Alien lab")
local alienforest = dropdown:Add("Alien Forest")
local glitch = dropdown:Add("Glitch")
local hackerportal = dropdown:Add("HackerPortal")

local dropdown2 = autofarm:AddDropdown("Select Teleport Area (Fantasy)", function(text)
    if text == "Ancient Island" then  -- Code
        local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas.Island.Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)

    elseif text == "Samurai Island" then
    
    elseif text == "Candy Island" then
    
    elseif text == "Haunted Island" then

    elseif text == "Hell Island" then

    elseif text == "Heaven Island" then

    end
end)
local ancient = dropdown2:Add("Ancient Island")  -- Options
local samurai = dropdown2:Add("Samurai Island")
local candy = dropdown2:Add("Candy Island")
local haunted = dropdown2:Add("Haunted Island")
local hell = dropdown2:Add("Hell Island")
local heaven = dropdown2:Add("Heaven Island")

local dropdown3 = autofarm:AddDropdown("Select Teleport Area (Spawn)", function(text)
    if text == "Spawn" then  -- Code
        print("o")
    elseif text == "Town" then
    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Town"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)

    elseif text == "Forest" then
    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Forest"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)

    elseif text == "Beach" then
    local targetColor = Color3.fromRGB(255, 255, 162)
local beachArea = workspace.__MAP.Areas:FindFirstChild("Beach")
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

if beachArea then
    for _, obj in ipairs(beachArea:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Name == "Ground" and obj.Color == targetColor then
            rootPart.CFrame = obj.CFrame + Vector3.new(0, 5, 0)
            print("Teleported to:", obj:GetFullName())
            break
        end
    end
else
    warn("Beach area not found.")
end


    elseif text == "Mine" then
    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Mine"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)

    elseif text == "Winter" then
    local player = game.Players.LocalPlayer
local character = player.Character or player.Character Added:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Winter"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)
    elseif text == "Glacier" then
    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Glacier"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)

    elseif text == "Desert" then
    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Desert"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 5, 0)

    elseif text == "Volcano" then
    local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Get the teleport part
local teleportPart = workspace.__MAP.Areas["Volcano"].Ground

-- Teleport the player a bit above the part to avoid getting stuck
rootPart.CFrame = teleportPart.CFrame + Vector3.new(0, 25, 0)

    end
end)
local town = dropdown3:Add("Town")  -- Options
local forest = dropdown3:Add("Forest")
local beach = dropdown3:Add("Beach")
local mine = dropdown3:Add("Mine")
local winter = dropdown3:Add("Winter")
local glacier = dropdown3:Add("Glacier")
local desert = dropdown3:Add("Desert")
local volcano = dropdown3:Add("Volcano")

autofarm:AddLabel("Chests")

local bigChestSwitch = autofarm:AddSwitch("Autofarm Big Chests", function(bool)
     -- toggle_god_mode(bool)
end)
bigChestSwitch:Set(false)

local chestPlatformSwitch = autofarm:AddSwitch("Teleport under chest (Private Platform)", function(bool)
     -- toggle_god_mode(bool)
end)
chestPlatformSwitch:Set(false)

local chestDropdown = autofarm:AddDropdown("Select Chest", function(text)
    if text == "Spawn" then  -- Code
        print("o")
    elseif text == "Forest" then
    print("k")
    elseif text == "Beach" then
    print("Weeeee")
    end
end)
local volcanoChest = chestDropdown:Add("Volcano")  -- Options
local fantasy = chestDropdown:Add("Fantasy")
local hauntedChest = chestDropdown:Add("Haunted")
local hellChest = chestDropdown:Add("Hell")
local heavenChest = chestDropdown:Add("Heaven")
local heavenbig = chestDropdown:Add("Heaven Big")

-- New label and slider at the bottom of AutoFarm tab
autofarm:AddLabel("Autofarm Settings")

local customSlider = autofarm:AddSlider("Breakable Aura Distance", function(value)
    _G.customSliderValue = value
    print("Custom slider value changed to:", value)
    -- Update sphere size in real-time if visualization is active
    if _G.showBreakableAura and breakableAuraSphere then
        local radius = value
        breakableAuraSphere.Size = Vector3.new(radius * 2, radius * 2, radius * 2)
    end
end, {
    ["min"] = 1,
    ["max"] = 250,
})

-- Modified Show Breakable Aura Switch with functionality
local breakableAuraSwitch = autofarm:AddSwitch("Show Breakable Aura", function(bool)
    if bool then
        startBreakableAuraVisualization()
    else
        stopBreakableAuraVisualization()
    end
end)
breakableAuraSwitch:Set(false)

-- Eggs Tab
local eggsTab = window:AddTab("Eggs") -- Name of tab
_G.autoBuyEgg = false
_G.eggName = "Hacker Egg"
_G.eggBuySpeed = 1

local function startAutoBuyEgg()
    task.spawn(function()
        local things = workspace:WaitForChild("__THINGS", 5)
        if not things then return end
        local remotes = things:WaitForChild("__REMOTES", 5)
        if not remotes then return end
        local buyEgg = remotes:WaitForChild("buy egg", 5)
        if not buyEgg then return end
       
        while _G.autoBuyEgg do
            local args = {
                {
                    _G.eggName,
                    false
                }
            }
            pcall(function()
                buyEgg:InvokeServer(unpack(args))
            end)
            task.wait(0.6 - (_G.eggBuySpeed * 0.1))
        end
    end)
end

local eggHatchSwitch = eggsTab:AddSwitch("auto fast hatch egg", function(bool)
    _G.autoBuyEgg = bool
    if bool then
        startAutoBuyEgg()
    end
end)

local speedSlider = eggsTab:AddSlider("buy egg speed", function(value)
    _G.eggBuySpeed = value
end, {
    ["min"] = 1,
    ["max"] = 5,
})

-- Misc Tab
local miscTab = window:AddTab("Misc") -- Name of tab
_G.Walkspeed = 16
_G.JumpHeight = 50
_G.Modifying = false

local walkSpeedSlider = miscTab:AddSlider("Set Walkspeed", function(value)
    _G.Walkspeed = value
end, {
    ["min"] = 1,
    ["max"] = 200,
})
local jumpHeightSlider = miscTab:AddSlider("Set Jumpheight", function(value)
    _G.JumpHeight = value
end, {
    ["min"] = 1,
    ["max"] = 500,
})
local modifyingSwitch = miscTab:AddSwitch("Modifying?", function(bool)
    _G.Modifying = bool
end)

task.spawn(function()
    while task.wait() do
        if _G.Modifying then
            humanoid.WalkSpeed = _G.Walkspeed
            humanoid.JumpHeight = _G.JumpHeight
        else
            humanoid.WalkSpeed = 16
            humanoid.JumpHeight = 50
        end
    end
end)

modifyingSwitch:Set(false)
jumpHeightSlider:Set(50)
walkSpeedSlider:Set(16)
speedSlider:Set(1)
eggHatchSwitch:Set(false)

-- Cleanup when player leaves
Players.PlayerRemoving:Connect(function(player)
    if player == Players.LocalPlayer then
        removeVoidProtection()
        removeBreakableAuraSphere()
    end
end)

-- Additional cleanup when character respawns
Players.LocalPlayer.CharacterAdded:Connect(function(character)
    char = character
    humanoid = character:WaitForChild("Humanoid")
    
    -- Restart aura visualization if it was active
    if _G.showBreakableAura then
        task.wait(1) -- Wait for character to fully load
        startBreakableAuraVisualization()
    end
end)
