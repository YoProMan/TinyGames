-- ========================================
-- LIBRARY AND WINDOW INITIALIZATION
-- ========================================
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/memejames/elerium-v2-ui-library//main/Library", true))()
local window = library:AddWindow("TINY Games", {
    main_color = Color3.fromRGB(41, 74, 122),
    min_size = Vector2.new(700, 500),
    can_resize = false,
})

-- ========================================
-- SERVICES AND GLOBAL VARIABLES
-- ========================================
local Players = game:GetService("Players")
local TS = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- Global variables for orb collection
_G.collectOrbs = false
local orbConnection = nil

-- Global variables for autofarm
_G.autoFarmEnabled = false
local autoFarmConnection = nil

-- Global variables for teleport
_G.teleportAround = false
local teleportConnection = nil
local voidProtectionPart = nil

-- Global variables for breakable aura visualization
_G.showBreakableAura = false
_G.customSliderValue = 250
local breakableAuraSphere = nil
local auraUpdateConnection = nil

-- Global variables for egg hatching
_G.autoBuyEgg = false
_G.eggName = "Hacker Egg"
_G.eggBuySpeed = 1

-- Global variables for misc features
_G.Walkspeed = 16
_G.JumpHeight = 50
_G.Modifying = false

-- Player references
local plr = Players.LocalPlayer
local char = plr.Character
local humanoid = char.Humanoid

-- ========================================
-- BREAKABLE AURA FUNCTIONS
-- ========================================
local function createBreakableAuraSphere()
    if breakableAuraSphere then
        breakableAuraSphere:Destroy()
    end
    
    breakableAuraSphere = Instance.new("Part")
    breakableAuraSphere.Name = "BreakableAuraSphere"
    breakableAuraSphere.Shape = Enum.PartType.Ball
    breakableAuraSphere.Material = Enum.Material.ForceField
    breakableAuraSphere.Transparency = 0.7
    breakableAuraSphere.Anchored = true
    breakableAuraSphere.CanCollide = false
    breakableAuraSphere.BrickColor = BrickColor.new("Bright green")
    breakableAuraSphere.CastShadow = false
    breakableAuraSphere.Parent = workspace
    
    local radius = _G.customSliderValue or 250
    breakableAuraSphere.Size = Vector3.new(radius * 2, radius * 2, radius * 2)
    
    return breakableAuraSphere
end

local function updateBreakableAuraSphere()
    local player = Players.LocalPlayer
    if not player then return end
    local character = player.Character
    if not character then return end
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    if not breakableAuraSphere then
        createBreakableAuraSphere()
    end
    
    breakableAuraSphere.Position = HumanoidRootPart.Position
    
    local radius = _G.customSliderValue or 250
    breakableAuraSphere.Size = Vector3.new(radius * 2, radius * 2, radius * 2)
end

local function removeBreakableAuraSphere()
    if breakableAuraSphere then
        breakableAuraSphere:Destroy()
        breakableAuraSphere = nil
    end
    if auraUpdateConnection then
        auraUpdateConnection:Disconnect()
        auraUpdateConnection = nil
    end
end

local function startBreakableAuraVisualization()
    _G.showBreakableAura = true
    createBreakableAuraSphere()
    
    auraUpdateConnection = RunService.Heartbeat:Connect(function()
        if _G.showBreakableAura then
            updateBreakableAuraSphere()
        end
    end)
end

local function stopBreakableAuraVisualization()
    _G.showBreakableAura = false
    removeBreakableAuraSphere()
end

-- ========================================
-- VOID PROTECTION FUNCTIONS
-- ========================================
local function createVoidProtection()
    if voidProtectionPart then
        voidProtectionPart:Destroy()
    end
    
    voidProtectionPart = Instance.new("Part")
    voidProtectionPart.Name = "VoidProtection"
    voidProtectionPart.Size = Vector3.new(10, 1, 10)
    voidProtectionPart.Material = Enum.Material.ForceField
    voidProtectionPart.Transparency = 0.8
    voidProtectionPart.Anchored = true
    voidProtectionPart.CanCollide = true
    voidProtectionPart.BrickColor = BrickColor.new("Bright blue")
    voidProtectionPart.Parent = workspace
    
    return voidProtectionPart
end

local function updateVoidProtection()
    local player = Players.LocalPlayer
    if not player then return end
    local character = player.Character
    if not character then return end
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    if not voidProtectionPart then
        createVoidProtection()
    end
    
    local playerPos = HumanoidRootPart.Position
    voidProtectionPart.CFrame = CFrame.new(playerPos.X, playerPos.Y - 10, playerPos.Z)
end

local function removeVoidProtection()
    if voidProtectionPart then
        voidProtectionPart:Destroy()
        voidProtectionPart = nil
    end
end

-- ========================================
-- TELEPORT FUNCTIONS
-- ========================================
local function CheckTeleportDistance(Mesh)
    local player = Players.LocalPlayer
    if not player then return false end
    local character = player.Character
    if not character then return false end
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return false end
    
    local distance = (HumanoidRootPart.Position - Mesh.Position).Magnitude
    return distance <= 100
end

local function TeleportAround()
    if teleportConnection then
        task.cancel(teleportConnection)
        teleportConnection = nil
    end
    
    teleportConnection = task.spawn(function()
        while _G.teleportAround do
            task.wait(5)
            
            local things = workspace:FindFirstChild("__THINGS")
            if not things then continue end
            local coins = things:FindFirstChild("Coins")
            if not coins then continue end
            
            local player = Players.LocalPlayer
            if not player then continue end
            local character = player.Character
            if not character then continue end
            local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if not HumanoidRootPart then continue end
            
            for i, folder in pairs(coins:GetChildren()) do
                if not _G.teleportAround then break end
                
                local coinMesh = folder:FindFirstChild("Coin")
                if coinMesh then
                    local inRange = CheckTeleportDistance(coinMesh)
                    if inRange then
                        local targetCFrame = coinMesh.CFrame + Vector3.new(0, 5, 0)
                        
                        local TI = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                        local Tween = TS:Create(HumanoidRootPart, TI, {CFrame = targetCFrame})
                        Tween:Play()
                        
                        if _G.teleportAround then
                            updateVoidProtection()
                        end
                        
                        Tween.Finished:Wait()
                        
                        if _G.teleportAround then
                            updateVoidProtection()
                        end
                    end
                end
            end
        end
    end)
end

local function startTeleportAround()
    _G.teleportAround = true
    createVoidProtection()
    TeleportAround()
    
    task.spawn(function()
        while _G.teleportAround do
            task.wait(0.5)
            updateVoidProtection()
        end
    end)
end

local function stopTeleportAround()
    _G.teleportAround = false
    if teleportConnection then
        task.cancel(teleportConnection)
        teleportConnection = nil
    end
    removeVoidProtection()
end

-- ========================================
-- ORB COLLECTION FUNCTIONS
-- ========================================
local function ClaimAllOrbs()
    if not _G.collectOrbs then return end
    
    local player = Players.LocalPlayer
    if not player then return end
    local character = player.Character or player.CharacterAdded:Wait()
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end
    
    local orbsFolder = workspace:FindFirstChild("__THINGS")
    if not orbsFolder then return end
    orbsFolder = orbsFolder:FindFirstChild("Orbs")
    if not orbsFolder then return end
    
    local allorbs = orbsFolder:GetChildren()
    for _, orb in pairs(allorbs) do
        if orb:IsA("BasePart") or orb:IsA("Model") then
            local ti = TweenInfo.new(
                0.1,
                Enum.EasingStyle.Quad,
                Enum.EasingDirection.In
            )
            local tween = TS:Create(orb, ti, {CFrame = HumanoidRootPart.CFrame})
            tween:Play()
        end
    end
end

local function startOrbCollection()
    if orbConnection then
        orbConnection:Disconnect()
        orbConnection = nil
    end
    
    ClaimAllOrbs()
    
    local orbsFolder = workspace:FindFirstChild("__THINGS")
    if orbsFolder then
        orbsFolder = orbsFolder:FindFirstChild("Orbs")
        if orbsFolder then
            orbConnection = orbsFolder.ChildAdded:Connect(function()
                if _G.collectOrbs then
                    wait(0.1)
                    ClaimAllOrbs()
                end
            end)
        end
    end
end

local function stopOrbCollection()
    if orbConnection then
        orbConnection:Disconnect()
        orbConnection = nil
    end
end

-- ========================================
-- AUTOFARM FUNCTIONS
-- ========================================
local function GetListLength(list)
    local len = 1
    for i, v in pairs(list) do
        len += 1
    end
    return len
end

local function GetPlayerPets()
    local Pets = workspace:FindFirstChild("__THINGS")
    if not Pets then return {} end
    Pets = Pets:FindFirstChild("Pets")
    if not Pets then return {} end
    
    local plrpets = {}
    for i, pet in pairs(Pets:GetChildren()) do
        local Owner = pet:GetAttribute("Owner")
        if Owner == Players.LocalPlayer.Name then
            plrpets[GetListLength(plrpets)] = pet.Name
        end
    end
    return plrpets
end

local function AttackCoin(coinid)
    local playerpets = GetPlayerPets()
    if #playerpets == 0 then return end
    
    local petToAttack = playerpets[math.random(1, GetListLength(playerpets))]
    
    pcall(function()
        workspace.__THINGS.__REMOTES["join coin"]:InvokeServer({
            [1] = coinid,
            [2] = {
                [1] = petToAttack,
            },
        })
        workspace.__THINGS.__REMOTES["change pet target"]:FireServer({
            [1] = petToAttack,
            [2] = "Coin",
            [3] = coinid,
        })
        workspace.__THINGS.__REMOTES["farm coin"]:FireServer({
            [1] = coinid,
            [2] = petToAttack,
        })
    end)
end

local function CheckDistance(mesh)
    local player = Players.LocalPlayer
    if not player then return false end
    local character = player.Character
    if not character then return false end
    local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return false end
    
    local distance = (HumanoidRootPart.Position - mesh.Position).Magnitude
    return distance <= (_G.customSliderValue or 250)
end

local function startAutoFarm()
    if autoFarmConnection then
        autoFarmConnection:Disconnect()
        autoFarmConnection = nil
    end
    
    autoFarmConnection = task.spawn(function()
        while _G.autoFarmEnabled do
            task.wait(1)
            
            local things = workspace:FindFirstChild("__THINGS")
            if not things then continue end
            local coins = things:FindFirstChild("Coins")
            if not coins then continue end
            
            for i, folder in pairs(coins:GetChildren()) do
                if not _G.autoFarmEnabled then break end
                
                local coinMesh = folder:FindFirstChild("Coin")
                if coinMesh then
                    local inRange = CheckDistance(coinMesh)
                    if inRange then
                        AttackCoin(folder.Name)
                    end
                end
            end
        end
    end)
end

local function stopAutoFarm()
    _G.autoFarmEnabled = false
    if autoFarmConnection then
        task.cancel(autoFarmConnection)
        autoFarmConnection = nil
    end
end

-- ========================================
-- EGG HATCHING FUNCTIONS
-- ========================================
local function startAutoBuyEgg()
    task.spawn(function()
        local things = workspace:WaitForChild("__THINGS", 5)
        if not things then return end
        local remotes = things:WaitForChild("__REMOTES", 5)
        if not remotes then return end
        local buyEgg = remotes:WaitForChild("buy egg", 5)
        if not buyEgg then return end
       
        while _G.autoBuyEgg do
            local args = {
                {
                    _G.eggName,
                    false
                }
            }
            pcall(function()
                buyEgg:InvokeServer(unpack(args))
            end)
            task.wait(0.6 - (_G.eggBuySpeed * 0.1))
        end
    end)
end

-- ========================================
-- TELEPORT AREA FUNCTIONS
-- ========================================
local function teleportToArea(areaName, offset)
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")
    local teleportPart = workspace.__MAP.Areas[areaName].Ground
    rootPart.CFrame = teleportPart.CFrame + (offset or Vector3.new(0, 5, 0))
end

local function teleportToBeach()
    local targetColor = Color3.fromRGB(255, 255, 162)
    local beachArea = workspace.__MAP.Areas:FindFirstChild("Beach")
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")

    if beachArea then
        for _, obj in ipairs(beachArea:GetDescendants()) do
            if obj:IsA("BasePart") and obj.Name == "Ground" and obj.Color == targetColor then
                rootPart.CFrame = obj.CFrame + Vector3.new(0, 5, 0)
                print("Teleported to:", obj:GetFullName())
                break
            end
        end
    else
        warn("Beach area not found.")
    end
end

-- ========================================
-- TABS INITIALIZATION
-- ========================================
local autofarm = window:AddTab("AutoFarm")
autofarm:Show()
local eggsTab = window:AddTab("Eggs")
local miscTab = window:AddTab("Misc")

-- ========================================
-- SWITCHES SECTION
-- ========================================
autofarm:AddLabel("Main")

local autofarmSwitch = autofarm:AddSwitch("Autofarm (Breakable aura)", function(bool)
    _G.autoFarmEnabled = bool
    if bool then
        startAutoFarm()
    else
        stopAutoFarm()
    end
end)

local orbSwitch = autofarm:AddSwitch("Collect orbs", function(bool)
    _G.collectOrbs = bool
    if bool then
        startOrbCollection()
    else
        stopOrbCollection()
    end
end)

local lootbagSwitch = autofarm:AddSwitch("Collect Lootbags", function(bool)
end)

local teleportSwitch = autofarm:AddSwitch("Teleport To Middle", function(bool)
    if bool then
        startTeleportAround()
    else
        stopTeleportAround()
    end
end)

autofarm:AddLabel("Chests")

local bigChestSwitch = autofarm:AddSwitch("Autofarm Big Chests", function(bool)
end)

local chestPlatformSwitch = autofarm:AddSwitch("Teleport under chest (Private Platform)", function(bool)
end)

local breakableAuraSwitch = autofarm:AddSwitch("Show Breakable Aura", function(bool)
    if bool then
        startBreakableAuraVisualization()
    else
        stopBreakableAuraVisualization()
    end
end)

local eggHatchSwitch = eggsTab:AddSwitch("auto fast hatch egg", function(bool)
    _G.autoBuyEgg = bool
    if bool then
        startAutoBuyEgg()
    end
end)

local modifyingSwitch = miscTab:AddSwitch("Modifying?", function(bool)
    _G.Modifying = bool
end)

-- ========================================
-- SLIDERS SECTION
-- ========================================
autofarm:AddLabel("Autofarm Settings")

local customSlider = autofarm:AddSlider("Breakable Aura Distance", function(value)
    _G.customSliderValue = value
    print("Custom slider value changed to:", value)
    if _G.showBreakableAura and breakableAuraSphere then
        local radius = value
        breakableAuraSphere.Size = Vector3.new(radius * 2, radius * 2, radius * 2)
    end
end, {
    ["min"] = 1,
    ["max"] = 500,
})

local speedSlider = eggsTab:AddSlider("buy egg speed", function(value)
    _G.eggBuySpeed = value
end, {
    ["min"] = 1,
    ["max"] = 5,
})

local walkSpeedSlider = miscTab:AddSlider("Set Walkspeed", function(value)
    _G.Walkspeed = value
end, {
    ["min"] = 1,
    ["max"] = 200,
})

local jumpHeightSlider = miscTab:AddSlider("Set Jumpheight", function(value)
    _G.JumpHeight = value
end, {
    ["min"] = 1,
    ["max"] = 500,
})

-- ========================================
-- DROPDOWNS SECTION
-- ========================================
local dropdown = autofarm:AddDropdown("Select Teleport Area (Tech)", function(text)
    if text == "Tech City" then
        teleportToArea("Tech City")
    elseif text == "Dark Tech" then
        teleportToArea("Dark Tech")
    elseif text == "Steampunk" then
        teleportToArea("Steampunk")
    elseif text == "Alien lab" then
        teleportToArea("Alien Lab")
    elseif text == "Alien Forest" then
        teleportToArea("Alien Forest")
    elseif text == "Glitch" then
        teleportToArea("Glitch")
    elseif text == "HackerPortal" then
        teleportToArea("Hacker Portal")
    end
end)

local dropdown2 = autofarm:AddDropdown("Select Teleport Area (Fantasy)", function(text)
    if text == "Ancient Island" then
        teleportToArea("Island")
    elseif text == "Samurai Island" then
    elseif text == "Candy Island" then
    elseif text == "Haunted Island" then
    elseif text == "Hell Island" then
    elseif text == "Heaven Island" then
    end
end)

local dropdown3 = autofarm:AddDropdown("Select Teleport Area (Spawn)", function(text)
    if text == "Spawn" then
        print("o")
    elseif text == "Town" then
        teleportToArea("Town")
    elseif text == "Forest" then
        teleportToArea("Forest")
    elseif text == "Beach" then
        teleportToBeach()
    elseif text == "Mine" then
        teleportToArea("Mine")
    elseif text == "Winter" then
        teleportToArea("Winter")
    elseif text == "Glacier" then
        teleportToArea("Glacier")
    elseif text == "Desert" then
        teleportToArea("Desert")
    elseif text == "Volcano" then
        teleportToArea("Volcano", Vector3.new(0, 25, 0))
    end
end)

local chestDropdown = autofarm:AddDropdown("Select Chest", function(text)
    if text == "Spawn" then
        print("o")
    elseif text == "Forest" then
        print("k")
    elseif text == "Beach" then
        print("Weeeee")
    end
end)

-- ========================================
-- DROPDOWN OPTIONS SETUP
-- ========================================
dropdown:Add("Tech City")
dropdown:Add("Dark Tech")
dropdown:Add("Steampunk")
dropdown:Add("Alien lab")
dropdown:Add("Alien Forest")
dropdown:Add("Glitch")
dropdown:Add("HackerPortal")

dropdown2:Add("Ancient Island")
dropdown2:Add("Samurai Island")
dropdown2:Add("Candy Island")
dropdown2:Add("Haunted Island")
dropdown2:Add("Hell Island")
dropdown2:Add("Heaven Island")

dropdown3:Add("Town")
dropdown3:Add("Forest")
dropdown3:Add("Beach")
dropdown3:Add("Mine")
dropdown3:Add("Winter")
dropdown3:Add("Glacier")
dropdown3:Add("Desert")
dropdown3:Add("Volcano")

chestDropdown:Add("Volcano")
chestDropdown:Add("Fantasy")
chestDropdown:Add("Haunted")
chestDropdown:Add("Hell")
chestDropdown:Add("Heaven")
chestDropdown:Add("Heaven Big")

-- ========================================
-- DEFAULT VALUES AND INITIALIZATION
-- ========================================
autofarmSwitch:Set(false)
orbSwitch:Set(false)
lootbagSwitch:Set(false)
teleportSwitch:Set(false)
bigChestSwitch:Set(false)
chestPlatformSwitch:Set(false)
breakableAuraSwitch:Set(false)
eggHatchSwitch:Set(false)
modifyingSwitch:Set(false)

customSlider:Set(250)
speedSlider:Set(1)
walkSpeedSlider:Set(16)
jumpHeightSlider:Set(50)

-- ========================================
-- BACKGROUND TASKS AND EVENT HANDLERS
-- ========================================
task.spawn(function()
    while task.wait() do
        if _G.Modifying then
            humanoid.WalkSpeed = _G.Walkspeed
            humanoid.JumpHeight = _G.JumpHeight
        else
            humanoid.WalkSpeed = 16
            humanoid.JumpHeight = 50
        end
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if player == Players.LocalPlayer then
        removeVoidProtection()
        removeBreakableAuraSphere()
    end
end)

Players.LocalPlayer.CharacterAdded:Connect(function(character)
    char = character
    humanoid = character:WaitForChild("Humanoid")
    
    if _G.showBreakableAura then
        task.wait(1)
        startBreakableAuraVisualization()
    end
end)
